= Asciidoctor Demox
////
Big ol' comment

sittin' right 'tween this here title 'n header metadata
////
Dan Allen <thedoc@asciidoctor.org>
:description: A demo of Asciidoctor. This document \
              exercises numerous features of AsciiDoc \
              to test Asciidoctor compliance.
:library: Asciidoctor
:idprefix:
:numbered:
:imagesdir: images
:experimental:
//:toc: macro
:toc: preamble
:toc-title: pass:[<h3>Contents</h3>]
:css-signature: demo
//:max-width: 800px
//:doctype: book
//:sectids!:
ifdef::env-github[]
:note-caption: :information_source:
:tip-caption: :bulb:
endif::[]

This Wiki is a mix of tutorial and references for Sketches. 

toc::[]

== Hello World

Lets start with the following Hello World app. All apps in Sketches have 3 regions. An upper bar, where the name of the app is displayed, the amount of EEPROM and RAM memory available, and also the time.

image::hw.png[]

=== startScreen(void)

The code is quite simple:

[source,c]
----
#include "AquaOS.h"

namespace hello_world {
    void startScreen() { <1>
        drawCenteredString("Hello World!");
        toolbarAddHome(); <2>
    }
}
----
<1> All Sketches apps are written using callbacks, that is, functions that are called when certain functionality has to be performed. The function that is called when a app goes to the 
foreground is `startScreen`. 
<2> This function adds a *home* button in the toolbar, when pressed, the application is no longer on the foreground, and the desktop is shown.

TIP: Apps are always active, not only when they are in the foreground. They get called every second to perform it business logic, but only one app can be on the foreground at a given time. In other words, only one app receives the UI events.

== A Counter

This small applications counts how many times the toolbar button "+" is being pressed.

image::counter.png[]

[source,c]
----
#include "AquaOS.h"

namespace counter {
    void startScreen(); <1>
    int counter=0;      <2>
    void count(int param) { <3>
        counter++;
        goToScreen(startScreen); <4>
    }
    void startScreen() { <5>
        print(PSTR("Counting:")); // PSTR is important!
        print(counter);
        toolbarAdd(PSTR("+"), count, 0); <6> 
        toolbarAddHome();
    }
}
----
<1> We need the function prototype to help C++ compile.
<2> The variable we count the number of presses.
<3> Any function with this signature `void function(int param)` is called a *command* in Sketches. 
<4> A command can ask a screen to be drawn, using the `goToScreen(screen)` function. In this case, the screen that shows how many presses have been there, is also `startScreen`. 
<5> `startScreen` is called when the app goes to foreground *and* when the count function is invoked.
<6> Here a button with the label "+" is added. If pressed, the function `count` will be called with the parameter `0`. This parameter has no importance. PSTR is important, if missing, Sketches would crash.

=== Commands

Commands are called when a button is pressed in the toolbar. The *param* parameter is not always used, but must be in the signature. Commands can change the screen to another one. For example, a command `configure(int param)` could show a new screen with the calibration info and a toolbar adapted to calibration actions.

== Persistent Variables

In *A Counter* the variable counter will be reset to 0 everytime the microcontroller is powered off. There is a mechanism in Sketches that will keep the value of a variable in the EEPROM. This is very handy in apps that have a configuration, if this configuration would be deleted every time the microcontroller is disconnected, then it would be a lot of work to reconfigure it every time.

The use of persistant variables is almost transparent. There is no need to access the EEPROM directly, and only 2 functions have to be added, regardless of the amount of variables.

TIP: Persistent variables should not be changed frequently. Plan to change a persistent variable less than 10.000 times during the app *lifetime*. There is no problem reading the value of the variable as many times as you want!

[source,c]
----
#include "AquaOS.h"

namespace counter {
    void startScreen();

    int counter=0;

    void whenCreated() { <1>
        counter = 0; <2>
    }
	
    void registerVars() { <3>
        pregister(&counter); <4>
    }

    void count(int param) {
        counter++;
        goToScreen(startScreen);
    }

    void startScreen() {
        print(PSTR("Counting:"));
        print(counter);
        toolbarAdd(PSTR("+"), count, 0);
        toolbarAddHome();
    }

}
----
<1> When using persistent variables, they have to be initialized in the `whenCreated` function. 
<2> The variable is assigned a value, in a normal way. The asignment to the EEPROM happens automatically.
<3> This function turns the variable into a persistent variable. 
<4> The funcion name is `pregister`, and it is overloaded, so that it can be called with different parameter types. 

=== whenCreated()

This function will be called only once in the whole app lifetime. If the microcontroller is disconnected and connected again, this function won't be called. You can put more initialisation code here, 

=== registerVars()

This function should only register variables (with `pregister` and `mregister`). This function will be called in the background constantly by Sketches. Don't write any business logic here.

== Singleton App Instance

The philosophy of Sketches is that one App should be as simple as possible, and deal only with one hardware component. If you want to handle many similar hardware pieces, you should create many instances of the same App. In objected oriented programming, you would think of an app as the class, and the instances as the objects of that class.

For example, if you have an App that measures the PH of an aquarium, and you would like to measure many aquarium concurrently, then you would be tempted to write code that could manage many analog ports, keep the configuration of each probe, etc. This would make the app difficult to write, difficult to operate, and also unflexible (see Scripting). The preferred approach is to write an app that can handle *one* probe very good, and then create *many* instances of this app, each one of them independent.

If you want Sketches to avoid running more than one instance of one application, you have to implement the `cardinality()` function, returning `APP_CARDINALITY_ALWAYS_ONE` or `APP_CARDINALITY_MAX_ONE`

[source,c]
----
...
namespace counter {
    void startScreen();
    int counter=0;
	...

    void whenCreated() {
		...
		
	int cardinality() {
		return APP_CARDINALITY_ALWAYS_ONE;
	}
----

If you return `APP_CARDINALITY_ALWAYS_ONE`, then Sketches will create automatically one instance of the app when first powered on, it won't allow to delete it, nor to add a new instance of it. This is used by many default apps, that always have to be running (like the PortManager, or the Admin app).

On the other hand, if you return `APP_CARDINALITY_MAX_ONE`, you can delete the instance of the app, or create one instance, but not two.

=== int cardinality()

If you want to force it to run at most one instance of an application, you have to declare the function `int cardinality()` and return how many instances you want to allow.

There are three possibilities:

* APP_CARDINALITY_ALWAYS_ONE
* APP_CARDINALITY_MAX_ONE

== Multiple Instance Apps

By default, Sketches allows many instances of an app to be run concurrently. This presents a major problem, the declared variables are shared between all the instances. This may be ok sometimes, but normally you want each instance to have its own variable space. Fortunately, the mechanism is almost exactly the same as using persistent variables.

TIP: Persistent variables are automatically allocated for each instance, and not shared. Only variables that are volatile (in the RAM), have to be registered.

The following is a version where counter can have many instances, and the variables are volatile.

[source,c]
----
#include "AquaOS.h"

namespace counter {
    int counter=0;

    void whenPowered() { <1>
        counter = 0; <2>
    }
	
    void registerVars() { <3>
        mregister(&counter); <4>
    }

    void count(int param) {
	...
	
    void startScreen() {
		...
}
----
<1> When using persistent variables, they have to be initialized in the `whenPowered` function. 
<2> The variable is assigned a value, in a normal way. 
<3> This function turns the variable into a variable that can have different values for each instance. 
<4> The funcion name is `mregister`, and it is overloaded, so that it can be called with different parameter types. 

=== whenPowered()

This function is called every time the microcontroller is powered up. You can put any code you want here, but normally, the RAM variables are initialized.

=== registerVars() for multiple RAM variable instances

The variables that should not be shared, that is, the variables that should be owned by each instance, should be registered using `mregister`. A use case, would be a PH meter that averages the last 10 readings and shows that value. There is no use in putting those values in the EEPROM (as they change all the time), so it is better to put them in RAM. It is important that each of these values is *protected* for each instance, you don't want the values for different probes to be mixed.

== The Monitor

It is possible to use one microcontroller with Sketches to perform many tasks concurrently. For example, you could have one microcontroller measuring the PHs of 4 aquariums. As said before, the philosophy of Sketches is to write one app that measures the PH of one aquarium, and then have 4 instances of this app running concurrently.

The problem that arouses is how to show the information of all probes concurrently. If each instance is independent, and has no access to the others, how can you consolidate all the information in one screen?

The answer is the use of the Monitor app. 

image::monitor.png[]

The monitor asks each instance which information they want to show in a small portion of the screen (that is already small).

=== void monitor(int x, int y, int w, int h)

This function has to be implemented by each app that wants to show it state in the monitor. For example, the Water Alarm app shows a color rectangle in the monitor. Green if water is not being touch, red if it is.

[source,c]
----
void monitor(int x, int y, int w, int h) { <1>
    if (!configured()) { <2>
       setPrintX(x + margin);
       setPrintY(y + margin);
       setColor(colorWhite);
       drawString(PSTR("Not Configured"), x + margin, y + margin);
    }
    fillRect(x, y, w, h); <3>
    setColor(colorRed); <4>
    if (!touching())
       setColor(colorGreen);
    fillRect(x + 5 * margin, y + 2 * margin, w - 10 * margin, h - 4 * margin);
}
----
<1> The parameters represent a rectangle in the screen (x,y,x+w,y+h). Normally, the screen is splitted in 4 parts, but this could change in the future.
<2> If the instance is not configured (this is internal to that app), the message "Not configured" is shown in the monitor.
<3> The whole area is filled with the default background color
<4> A smaller rect is drawn, representing if water is being touched. `touching()` is a function that looks at the value of a digital port, connected to the water sensor.

== The State ==

